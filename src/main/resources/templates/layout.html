<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.11.1/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/styles.css">
    <title>밥친구</title>
</head>
<body>
<!-- 네비게이션바 -->
<nav th:replace="~{navbar :: navbarFragment}"></nav>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
<th:block layout:fragment="content"></th:block>
<!-- 기본 템플릿 안에 삽입될 내용 End -->

<!-- 메시지 박스 -->
<div class="message-box" id="messageBox">
    <div class="message-box-header">
        <strong>메시지</strong>
    </div>
    <div class="message-box-content">
        <!-- 메시지가 추가될 영역 -->
    </div>
    <div class="message-box-footer">
        <input type="text" placeholder="메시지 입력...">
        <button id="sendMessage">보내기</button>
    </div>
</div>

<!-- 메시지 창을 표시하는 버튼 -->
<button class="toggle-button" id="toggleButton">∧</button>

<script>
    // 메시지 박스 관련 스크립트
    document.querySelector('#sendMessage').addEventListener('click', function() {
        const input = document.querySelector('.message-box input');
        const content = document.querySelector('.message-box-content');
        const message = document.createElement('p');
        message.textContent = input.value;
        content.appendChild(message);
        input.value = '';
    });

    // 메시지 박스를 표시하는 버튼 이벤트 리스너
    document.querySelector('#toggleButton').addEventListener('click', function() {
        const messageBox = document.getElementById('messageBox');
        if (messageBox.classList.contains('visible')) {
            messageBox.classList.remove('visible');
            this.textContent = '∧';
        } else {
            messageBox.classList.add('visible');
            this.textContent = '∨';
        }
    });
</script>

<!--<script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=160268d49f0faa6e1c65fac9ce28c429&libraries=services"></script>-->
<script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=160268d49f0faa6e1c65fac9ce28c429"></script>
<script>
    var overlayOn = false, // 지도 위에 로드뷰 오버레이가 추가된 상태를 가지고 있을 변수
        container = document.getElementById('container'), // 지도와 로드뷰를 감싸고 있는 div 입니다
        mapWrapper = document.getElementById('mapWrapper'), // 지도를 감싸고 있는 div 입니다
        mapContainer = document.getElementById('map'), // 지도를 표시할 div 입니다
        rvContainer = document.getElementById('roadview'); //로드뷰를 표시할 div 입니다

    var mapCenter = new kakao.maps.LatLng(33.45042, 126.57091), // 지도의 중심좌표 (기본값)
        mapOption = {
            center: mapCenter, // 지도의 중심좌표
            level: 3 // 지도의 확대 레벨
        };

    // 지도를 표시할 div와 지도 옵션으로 지도를 생성합니다
    var map = new kakao.maps.Map(mapContainer, mapOption);

    // 로드뷰 객체를 생성합니다
    var rv = new kakao.maps.Roadview(rvContainer);

    // 좌표로부터 로드뷰 파노라마 ID를 가져올 로드뷰 클라이언트 객체를 생성합니다
    var rvClient = new kakao.maps.RoadviewClient();

    // 주소를 좌표로 변환하여 지도에 표시하는 함수
    function displayMap(address) {
        var geocoder = new kakao.maps.services.Geocoder();
        geocoder.addressSearch(address, function(result, status) {
            if (status === kakao.maps.services.Status.OK) {
                var coords = new kakao.maps.LatLng(result[0].y, result[0].x);
                map.setCenter(coords);
                marker.setPosition(coords);
            } else {
                console.error("Geocoding failed: " + status);
            }
        });
    }

    // 마커 이미지를 생성합니다
    var markImage = new kakao.maps.MarkerImage(
        'https://t1.daumcdn.net/localimg/localimages/07/2018/pc/roadview_minimap_wk_2018.png',
        new kakao.maps.Size(26, 46),
        {
            // 스프라이트 이미지를 사용합니다.
            // 스프라이트 이미지 전체의 크기를 지정하고
            spriteSize: new kakao.maps.Size(1666, 168),
            // 사용하고 싶은 영역의 좌상단 좌표를 입력합니다.
            // background-position으로 지정하는 값이며 부호는 반대입니다.
            spriteOrigin: new kakao.maps.Point(705, 114),
            offset: new kakao.maps.Point(13, 46)
        }
    );

    // 드래그가 가능한 마커를 생성합니다
    var marker = new kakao.maps.Marker({
        image: markImage,
        position: mapCenter,
        draggable: true
    });

    // 마커에 dragend 이벤트를 등록합니다
    kakao.maps.event.addListener(marker, 'dragend', function(mouseEvent) {
        // 현재 마커가 놓인 자리의 좌표입니다
        var position = marker.getPosition();
        // 마커가 놓인 위치를 기준으로 로드뷰를 설정합니다
        toggleRoadview(position);
    });

    // 지도에 클릭 이벤트를 등록합니다
    kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
        // 지도 위에 로드뷰 도로 오버레이가 추가된 상태가 아니면 클릭이벤트를 무시합니다
        if (!overlayOn) {
            return;
        }
        // 클릭한 위치의 좌표입니다
        var position = mouseEvent.latLng;
        // 마커를 클릭한 위치로 옮깁니다
        marker.setPosition(position);
        // 클릭한 위치를 기준으로 로드뷰를 설정합니다
        toggleRoadview(position);
    });

    // 전달받은 좌표(position)에 가까운 로드뷰의 파노라마 ID를 추출하여
    // 로드뷰를 설정하는 함수입니다
    function toggleRoadview(position) {
        rvClient.getNearestPanoId(position, 50, function(panoId) {
            // 파노라마 ID가 null 이면 로드뷰를 숨깁니다
            if (panoId === null) {
                toggleMapWrapper(true, position);
            } else {
                toggleMapWrapper(false, position);
                // panoId로 로드뷰를 설정합니다
                rv.setPanoId(panoId, position);
            }
        });
    }

    // 지도를 감싸고 있는 div의 크기를 조정하는 함수입니다
    function toggleMapWrapper(active, position) {
        if (active) {
            // 지도를 감싸고 있는 div의 너비가 100%가 되도록 class를 변경합니다
            container.className = '';
            // 지도의 크기가 변경되었기 때문에 relayout 함수를 호출합니다
            map.relayout();
            // 지도의 너비가 변경될 때 지도 중심을 입력받은 위치(position)로 설정합니다
            map.setCenter(position);
        } else {
            // 지도만 보여지고 있는 상태이면 지도의 너비가 50%가 되도록 class를 변경하여
            // 로드뷰가 함께 표시되게 합니다
            if (container.className.indexOf('view_roadview') === -1) {
                container.className = 'view_roadview';
                // 지도의 크기가 변경되었기 때문에 relayout 함수를 호출합니다
                map.relayout();
                // 지도의 너비가 변경될 때 지도 중심을 입력받은 위치(position)로 설정합니다
                map.setCenter(position);
            }
        }
    }

    // 지도 위의 로드뷰 도로 오버레이를 추가,제거하는 함수입니다
    function toggleOverlay(active) {
        if (active) {
            overlayOn = true;
            // 지도 위에 로드뷰 도로 오버레이를 추가합니다
            map.addOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
            // 지도 위에 마커를 표시합니다
            marker.setMap(map);
            // 마커의 위치를 지도 중심으로 설정합니다
            marker.setPosition(map.getCenter());
            // 로드뷰의 위치를 지도 중심으로 설정합니다
            toggleRoadview(map.getCenter());
        } else {
            overlayOn = false;
            // 지도 위의 로드뷰 도로 오버레이를 제거합니다
            map.removeOverlayMapTypeId(kakao.maps.MapTypeId.ROADVIEW);
            // 지도 위의 마커를 제거합니다
            marker.setMap(null);
        }
    }

    // 지도 위의 로드뷰 버튼을 눌렀을 때 호출되는 함수입니다
    function setRoadviewRoad() {
        var control = document.getElementById('roadviewControl');
        // 버튼이 눌린 상태가 아니면
        if (control.className.indexOf('active') === -1) {
            control.className = 'active';
            // 로드뷰 도로 오버레이가 보이게 합니다
            toggleOverlay(true);
        } else {
            control.className = '';
            // 로드뷰 도로 오버레이를 제거합니다
            toggleOverlay(false);
        }
    }

    // 로드뷰에서 X버튼을 눌렀을 때 로드뷰를 지도 뒤로 숨기는 함수입니다
    function closeRoadview() {
        var position = marker.getPosition();
        toggleMapWrapper(true, position);
    }

    // 페이지가 로드된 후 각 게시글에 대한 주소를 가져와서 지도를 표시합니다
window.onload = function() {
    // 각 게시글에 대한 주소를 담고 있는 배열
    var addresses = [];

    // 게시글 목록을 순회하면서 주소를 배열에 추가
    var elements = document.querySelectorAll('#boardList');
    elements.forEach(function(element) {
        var address = element.querySelector('.address').textContent;
        addresses.push(address);
    });

    // 각 게시글에 대한 주소를 순회하면서 지도를 표시합니다
    addresses.forEach(function(address) {
        displayMap(address);
    });
};

// displayMap 함수는 장소를 받아서 지도를 표시하는 함수입니다.
// 여기서는 간단한 예시로 alert로 장소를 출력하도록 하겠습니다.
function displayMap(address) {
    alert('장소: ' + address); // 여기에는 실제로 지도를 표시하는 로직을 넣어주셔야 합니다.
}
</script>
</body>
</html>
